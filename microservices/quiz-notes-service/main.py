"""
Quiz and Notes Service for GnyanSetu Platform (Lightweight Version)

ARCHITECTURE DESIGN:
===================
1. User uploads PDF → Lesson Service
2. Lesson Service generates lesson content (Gemini AI)
3. Teaching Service starts teaching (WebSocket)
4. WHILE teaching: Lesson Service generates quiz & notes in BACKGROUND
5. Quiz & notes are SAVED to lesson document in MongoDB
6. AFTER teaching: THIS SERVICE just RETRIEVES and DISPLAYS

This service is LIGHTWEIGHT - NO AI generation:
- Retrieves quiz from lesson.quiz_data field
- Retrieves notes from lesson.notes_data field
- Handles quiz submission and scoring
- Provides notes download
- Tracks quiz results
"""

import os
import logging
from datetime import datetime
from typing import List, Optional, Dict, Any
import json

from fastapi import FastAPI, HTTPException, Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response, JSONResponse
from pydantic import BaseModel, Field
from pymongo import MongoClient
from bson import ObjectId

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="GnyanSetu Quiz & Notes Service (Lightweight)",
    description="Retrieve and display quizzes and notes generated by Lesson Service",
    version="2.0.0"
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:3001", "http://localhost:8000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# MongoDB Connection
try:
    MONGODB_URI = os.getenv('MONGODB_URI', 'mongodb://localhost:27017/')
    client = MongoClient(MONGODB_URI)
    
    # Database: Gnyansetu_Lessons (where Lesson Service stores everything)
    lessons_db = client['Gnyansetu_Lessons']
    lessons_collection = lessons_db['lessons']
    
    # Database: Gnyansetu_Quiz_Results (just for tracking user submissions)
    results_db = client['Gnyansetu_Quiz_Results']
    quiz_results_collection = results_db['quiz_results']
    
    logger.info("✓ Connected to MongoDB successfully")
    logger.info("✓ Reading from: Gnyansetu_Lessons.lessons")
    logger.info("✓ Writing results to: Gnyansetu_Quiz_Results.quiz_results")
    
except Exception as e:
    logger.error(f"❌ MongoDB connection failed: {e}")
    lessons_collection = None
    quiz_results_collection = None

# ============================================================================
# Pydantic Models
# ============================================================================

class QuizQuestion(BaseModel):
    question: str
    options: List[str]
    correct_answer: str
    explanation: Optional[str] = None
    difficulty: Optional[str] = "medium"

class QuizSubmission(BaseModel):
    lesson_id: str
    user_id: str
    answers: List[Dict[str, Any]]  # [{"question_index": 0, "selected_option": "..."}]

class QuizResult(BaseModel):
    result_id: str
    lesson_id: str
    user_id: str
    score: int
    total_questions: int
    percentage: float
    answers: List[Dict[str, Any]]
    submitted_at: datetime

class NotesSection(BaseModel):
    title: str
    content: str

class NotesData(BaseModel):
    notes_id: str
    lesson_id: str
    lesson_title: str
    summary: str
    sections: List[NotesSection]
    key_takeaways: List[str]
    generated_at: datetime

# ============================================================================
# Helper Functions
# ============================================================================

def get_lesson_from_db(lesson_id: str) -> Optional[Dict[str, Any]]:
    """Retrieve lesson document from MongoDB"""
    if not lessons_collection:
        raise HTTPException(status_code=503, detail="Database not available")
    
    try:
        lesson = lessons_collection.find_one({"_id": ObjectId(lesson_id)})
        if lesson:
            lesson['_id'] = str(lesson['_id'])
        return lesson
    except Exception as e:
        logger.error(f"Error fetching lesson {lesson_id}: {e}")
        return None

def calculate_score(quiz_questions: List[Dict], user_answers: List[Dict]) -> Dict[str, Any]:
    """Calculate quiz score based on correct answers"""
    correct_count = 0
    detailed_results = []
    
    for answer in user_answers:
        question_index = answer.get('question_index')
        selected_option = answer.get('selected_option')
        
        if question_index < len(quiz_questions):
            question = quiz_questions[question_index]
            correct_answer = question.get('correct_answer')
            is_correct = (selected_option == correct_answer)
            
            if is_correct:
                correct_count += 1
            
            detailed_results.append({
                "question_index": question_index,
                "question": question.get('question'),
                "selected_option": selected_option,
                "correct_answer": correct_answer,
                "is_correct": is_correct,
                "explanation": question.get('explanation', 'No explanation available')
            })
    
    total_questions = len(quiz_questions)
    percentage = (correct_count / total_questions * 100) if total_questions > 0 else 0
    
    return {
        "score": correct_count,
        "total_questions": total_questions,
        "percentage": round(percentage, 2),
        "detailed_results": detailed_results
    }


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    # PyMongo Collection objects don't support bool(), must compare with None
    db_status = "connected" if lessons_collection is not None else "disconnected"
    
    return {
        "status": "healthy",
        "service": "quiz-notes-service",
        "version": "2.0.0",
        "architecture": "lightweight-retrieval-only",
        "database": db_status,
        "timestamp": datetime.utcnow().isoformat()
    }

# ============================================================================
# Quiz Endpoints
# ============================================================================

@app.get("/api/quiz/get/{lesson_id}")
async def get_quiz(
    lesson_id: str,
    user_id: str = Query(..., description="User ID"),
):
    """
    Retrieve quiz for a lesson
    
    The quiz is generated ASYNCHRONOUSLY by Lesson Service while teaching happens.
    This endpoint checks:
    1. If quiz exists → return it
    2. If still generating → return 202 status (still processing)
    3. If failed → return error
    """
    try:
        # Get lesson from database
        lesson = get_lesson_from_db(lesson_id)
        if not lesson:
            raise HTTPException(status_code=404, detail="Lesson not found")
        
        # Check quiz/notes generation status
        quiz_notes_status = lesson.get('quiz_notes_status', 'unknown')
        
        # Check if quiz data exists and has questions
        quiz_data = lesson.get('quiz_data', {})
        has_questions = bool(quiz_data.get('questions'))
        
        if not has_questions:
            # Quiz not ready yet
            if quiz_notes_status == 'generating':
                return JSONResponse(
                    status_code=202,  # Accepted but not ready
                    content={
                        "status": "generating",
                        "message": "Quiz is being generated in the background. Please try again in a moment.",
                        "lesson_id": lesson_id,
                        "user_id": user_id
                    }
                )
            elif quiz_notes_status == 'failed':
                raise HTTPException(
                    status_code=500,
                    detail=f"Quiz generation failed: {lesson.get('quiz_notes_error', 'Unknown error')}"
                )
            else:
                raise HTTPException(
                    status_code=404,
                    detail="Quiz not yet generated. Please wait for lesson generation to complete."
                )
        
        # Quiz is ready! Return it
        questions = quiz_data.get('questions', [])
        
        return {
            "quiz_id": lesson_id,
            "lesson_id": lesson_id,
            "lesson_title": lesson.get('lesson_title', 'Lesson'),
            "questions": questions,
            "total_questions": len(questions),
            "generated_at": str(lesson.get('quiz_notes_generated_at', '')),
            "user_id": user_id,
            "status": "ready"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving quiz: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving quiz: {str(e)}")

@app.post("/api/quiz/submit")
async def submit_quiz(submission: QuizSubmission):
    """
    Submit quiz answers and get results
    """
    try:
        # Get lesson to access quiz questions
        lesson = get_lesson_from_db(submission.lesson_id)
        if not lesson:
            raise HTTPException(status_code=404, detail="Lesson not found")
        
        quiz_data = lesson.get('quiz_data')
        if not quiz_data or not quiz_data.get('questions'):
            raise HTTPException(status_code=404, detail="Quiz data not found")
        
        # Calculate score
        result = calculate_score(quiz_data['questions'], submission.answers)
        
        # Save result to database
        result_doc = {
            "lesson_id": submission.lesson_id,
            "user_id": submission.user_id,
            "score": result['score'],
            "total_questions": result['total_questions'],
            "percentage": result['percentage'],
            "answers": submission.answers,
            "detailed_results": result['detailed_results'],
            "submitted_at": datetime.utcnow()
        }
        
        if quiz_results_collection:
            insert_result = quiz_results_collection.insert_one(result_doc)
            result_doc['_id'] = str(insert_result.inserted_id)
        
        return {
            "result_id": result_doc.get('_id', 'temp_id'),
            "score": result['score'],
            "total_questions": result['total_questions'],
            "percentage": result['percentage'],
            "passed": result['percentage'] >= 60,
            "detailed_results": result['detailed_results'],
            "submitted_at": result_doc['submitted_at'].isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error submitting quiz: {e}")
        raise HTTPException(status_code=500, detail=f"Error submitting quiz: {str(e)}")

@app.get("/api/quiz/results/{user_id}")
async def get_quiz_results(user_id: str):
    """Get quiz result history for a user"""
    try:
        if not quiz_results_collection:
            raise HTTPException(status_code=503, detail="Results database not available")
        
        results = list(quiz_results_collection.find(
            {"user_id": user_id}
        ).sort("submitted_at", -1).limit(50))
        
        for result in results:
            result['_id'] = str(result['_id'])
            result['submitted_at'] = result['submitted_at'].isoformat()
        
        return {
            "user_id": user_id,
            "total_quizzes": len(results),
            "results": results
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching quiz results: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching results: {str(e)}")

# ============================================================================
# Notes Endpoints
# ============================================================================

@app.get("/api/notes/get/{lesson_id}")
async def get_notes(
    lesson_id: str,
    user_id: str = Query(..., description="User ID")
):
    """
    Retrieve notes for a lesson
    
    The notes are generated ASYNCHRONOUSLY by Lesson Service while teaching happens.
    This endpoint checks:
    1. If notes exist → return them
    2. If still generating → return 202 status (still processing)
    3. If failed → return error
    """
    try:
        # Get lesson from database
        lesson = get_lesson_from_db(lesson_id)
        if not lesson:
            raise HTTPException(status_code=404, detail="Lesson not found")
        
        # Check quiz/notes generation status
        quiz_notes_status = lesson.get('quiz_notes_status', 'unknown')
        
        # Check if notes data exists and has content
        notes_data = lesson.get('notes_data', {})
        has_sections = bool(notes_data.get('sections'))
        
        if not has_sections:
            # Notes not ready yet
            if quiz_notes_status == 'generating':
                return JSONResponse(
                    status_code=202,  # Accepted but not ready
                    content={
                        "status": "generating",
                        "message": "Notes are being generated in the background. Please try again in a moment.",
                        "lesson_id": lesson_id,
                        "user_id": user_id
                    }
                )
            elif quiz_notes_status == 'failed':
                raise HTTPException(
                    status_code=500,
                    detail=f"Notes generation failed: {lesson.get('quiz_notes_error', 'Unknown error')}"
                )
            else:
                raise HTTPException(
                    status_code=404,
                    detail="Notes not yet generated. Please wait for lesson generation to complete."
                )
        
        # Notes are ready! Return them
        return {
            "notes_id": lesson_id,
            "lesson_id": lesson_id,
            "lesson_title": lesson.get('lesson_title', 'Lesson'),
            "title": notes_data.get('title', 'Notes'),
            "summary": notes_data.get('summary', ''),
            "sections": notes_data.get('sections', []),
            "key_terms": notes_data.get('key_terms', []),
            "generated_at": str(lesson.get('quiz_notes_generated_at', '')),
            "user_id": user_id,
            "status": "ready"
        }
        
        return {
            "notes_id": lesson_id,
            "lesson_id": lesson_id,
            "lesson_title": lesson.get('title', 'Lesson'),
            "summary": notes_data.get('summary', ''),
            "sections": notes_data.get('sections', []),
            "key_takeaways": notes_data.get('key_takeaways', []),
            "generated_at": notes_data.get('generated_at'),
            "user_id": user_id
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving notes: {e}")
        raise HTTPException(status_code=500, detail=f"Error retrieving notes: {str(e)}")

@app.get("/api/notes/download/{lesson_id}")
async def download_notes(lesson_id: str):
    """Download notes as a text file"""
    try:
        # Get lesson from database
        lesson = get_lesson_from_db(lesson_id)
        if not lesson:
            raise HTTPException(status_code=404, detail="Lesson not found")
        
        notes_data = lesson.get('notes_data')
        if not notes_data:
            raise HTTPException(status_code=404, detail="Notes not found")
        
        # Format notes as text
        content_lines = []
        content_lines.append(f"Lesson: {lesson.get('title', 'Untitled')}")
        content_lines.append("=" * 60)
        content_lines.append("")
        
        # Summary
        if notes_data.get('summary'):
            content_lines.append("SUMMARY")
            content_lines.append("-" * 60)
            content_lines.append(notes_data['summary'])
            content_lines.append("")
        
        # Sections
        for section in notes_data.get('sections', []):
            content_lines.append(section.get('title', 'Section').upper())
            content_lines.append("-" * 60)
            content_lines.append(section.get('content', ''))
            content_lines.append("")
        
        # Key Takeaways
        if notes_data.get('key_takeaways'):
            content_lines.append("KEY TAKEAWAYS")
            content_lines.append("-" * 60)
            for i, takeaway in enumerate(notes_data['key_takeaways'], 1):
                content_lines.append(f"{i}. {takeaway}")
            content_lines.append("")
        
        content_lines.append("")
        content_lines.append(f"Generated: {notes_data.get('generated_at', 'Unknown')}")
        
        content = "\n".join(content_lines)
        
        return Response(
            content=content,
            media_type="text/plain",
            headers={
                "Content-Disposition": f"attachment; filename=lesson-notes-{lesson_id}.txt"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error downloading notes: {e}")
        raise HTTPException(status_code=500, detail=f"Error downloading notes: {str(e)}")

# ============================================================================
# Run the application
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv('SERVICE_PORT', 8005))
    uvicorn.run(app, host="0.0.0.0", port=port)
